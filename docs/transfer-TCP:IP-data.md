# 创建套接字

- 协议栈的内部结构
  - 最上层的是网络应用程序，也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序。
  - 应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询。
  - 再下面是操作系统内部，其中包括协议栈。协议栈分为上下两部分。
    - 上部分包括两块，分别是负责用 TCP 协议收发数据的部分和负责 UDP 协议收发数据的部分。
    - 下部分是 用 IP 协议控制网络包收发操作的部分。IP 中还包括 ICMP 协议和 ARP 协议。ICMP 协议用于告知网络包传送过程中产生的错误以及各种控制信息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

- 套接字的实体就是通信控制信息

  - 在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。存放控制信息的内存空间就是套接字的实体。

  - 通过命令 netstat 可以显示路由表、实际的网络连接以及每个一个网络接口设备的状态信息。

    ![netstat](/images/netstat.png)

    字段 Proto 表示协议类型；字段 Recv-Q 表示连接到此套接字的用户程序未复制的字节数；字段 Send-Q 表示远程主机未确认的字节数；Local Address 表示计算机本身（本地端）的 IP 地址和端口号。Foreign Address 表示通信对象（远程端）的 IP 地址和端口号；字段 State 表示通信状态；PID/Program name 表示该套接字的程序 PID（进程表示符）和名称。

- 调用 socket 时的操作

  - 协议栈首先会分配用于存放一个套接字所需的内存空间。随后在套接字的内存空间中写入表示这一初始状态的控制信息。
  - 接下来，返回套接字的描述符给应用程序。应用程序在向协议栈进行收发数据委托时需要提供这个描述符。



# 连接服务器

- 连接是什么意思

  - 连接时应用程序需要把服务器的 IP 地址和端口号等信息告诉协议栈，这是连接操作的目的之一。
  - 客户端放服务器传达开始通信的请求，也是连接操作的目的之一。
  - 连接实际上是通信双方交换控制信息。
  - 在执行数据收发操作时，我们还需要一块用来临时存放要收发数据的内存空间，这块空间称为缓冲区。

- 负责保存控制信息的头部

  - 控制信息可以大体分为两类。第一类是客户端和服务器相互联络时交换的控制信息。第二类是套接字（协议栈中的内存空间）中记录的信息。

  - TCP 头部格式

    | 字段名称                       | 长度（比特） | 含义                                                         |
    | ------------------------------ | ------------ | ------------------------------------------------------------ |
    | 发送方端口号                   | 16           | 发送网络包的程序的端口号                                     |
    | 接收方端口号                   | 16           | 网络包的接收方程序的端口号                                   |
    | 序号（发送数据的顺序编号）     | 32           | 发送方告知接收方该网络包发送的数据向防御所有发送数据的第几个字节 |
    | ACK 序号（发送数据的顺序编号） | 32           | 接收方告知发送方已经收到了所有数据的第几个字节。其中，ACK 是 acknowledge 的缩写 |
    | 数据偏移量                     | 4            | 表示数据部分的起始位置，也可以认为表示头部的长度             |
    | 保留                           | 6            | 该字段为保留，现在未使用                                     |
    | 控制位                         | 6            | 该字段中的每个比特分别表示以下通信控制含义。<br />URG：表示紧急指针字段有效<br />ACK：表示接受数据序号字段有效，一般表示数据已被接收方收到<br />PSH：表示通过 flush 操作发送的数据<br />RST：强制断开连接，用于异常中断的情况<br />SYN：发送方和接收方互相确认序号，表示连接操作<br />FIN：表示断开连接 |
    | 窗口                           | 16           | 接收方告知发送方窗口大小（即无需等待确认可一起发送的数据量） |
    | 校验和                         | 16           | 用来检查是否出错                                             |
    | 紧急指针                       | 16           | 表示紧急处理的数据位置                                       |
    | 可选字段                       | 可变长度     | 除了上面的固定头部字段之外，还可以添加可选字段，但除了连接操作之外，很少使用可选字段 |

- 连接操作的实际过程

  - 首先应用程序调用 Socket 库的 connect 组件。

    ```c
    connect(<描述符>，<服务器 IP 地址和端口号>，…)
    ```

  - 随后 TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息。此交互过程包含下面几个步骤：

    - 在 TCP 模块出创建表示连接控制信息的头部，如上表所示。
    - TCP 模块将信息传递给 IP 模块并委托它进行发送。
    - 网络包经过网络到达服务器，服务器上的 IP 模块会讲接收到的数据传递给 TCP 模块。
    - TCP 模块根据头部中的信息找到端口号对应的套接字。并在其中写入相应的信息，并将状态改为正在连接。
    - 服务器的 TCP 模块会返回响应。此时将 ACK 设为 1 表示已经接收到相应的网络包，并接受连接。如果因为某些原因不接受连接，那么将不设置 SYN，而是将 RST 比特设置为 1。
    - 网络包返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。如果成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕。
    - 客户端将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到了。



# 收发数据

- 将 HTTP 请求消息交给协议栈

  - 应用程序调用 Socket 库的 write 程序组件，并指定发送数据的长度。

  - 协议栈不关心应用程序传来的数据是什么内容。

  - 协议栈收到数据后就马上发送，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。但是应用程序也可以指定协议栈 “不等待填满缓冲区直接发送”。

  - 两个因素判断网络包发送的时机（协议栈控制）

    - 每个网络包能够容纳的长度。协议栈回更具一个叫做 MTU（Maximum Transmission Unit）的参数进行判断。MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS（Maximum Segment Size）。
    - 时间。协议栈的内部有一个计时器，当经过一定时间之后（时间很短，以浩渺为单位进行计算），就会把网络包发送出去。

  - MTU 与 MSS

    |                     |          |   MTU   |   MTU    | MSS（MTU） |      |
    | :-----------------: | :------: | :-----: | :------: | :--------: | :--: |
    | 报头 / 起始帧分界符 | MAC 头部 | IP 头部 | TCP 头部 |    数据    | FCS  |

- 对较大的数据进行拆分

  当 HTTP 请求消息超过 MSS 的长度时，这时发送缓冲区的数据会被以 MSS 长度为单位进行拆分。

- 使用 ACK 号确认网络包已收到

  - 发送方 TCP 模块在拆分数据时，先计算每一块数据相当于从开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部的序号字段中。
  - 接收方 TCP 模块通过整个网络包的长度减去数据偏移量得到数据的长度，然后将序号和数据的长度进行相加得到的数值写入 TCP 头部的序号字段中发送给发送方。
  - 实际通信中，开始的序号是一个随机数，并且在 SYN 设为 1 的时候，将这个随机数填入序号字段中。
  - 实际过程
    - 客户端在连接时计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器。
    - 服务器通过这个初始值计算出 ACK 号并返回给客户端。初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。同时服务器计算出从服务器到客户端方向通信相关的序号初始值并发送给客户端。
    - 客户端根据服务器发来的初始值计算出 ACK 号并发回给服务器。
  - 为什么是三次握手建立连接而不是两次或者四次？（个人理解，轻拍）
    - 首先先理解为什么要先建立连接？建立连接的目的是交换控制信息，例如：端口号、初始序列号、窗口大小。至于为什么要交换控制信息，一方面是为了提高效率，另一方面是为了确保安全性。
    - 两次握手：只能有一方能够确认自己的控制是否被对方接受，无法保证安全。
    - 四次握手：没必要，三次握手就能交换控制信息。（以后面试官问到为什么不要四次握手，我们可以反问面试官一个问题 — 你能告诉我第四次握手时应该发送什么消息？）

- 根据网络平均往返时间调整 ACK 号等待时间

  TCP采用了动态调整等待时间的方法。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号能马上返回，则相应缩短等待时间。

- 使用窗口有效管理 ACK 号
  - 每发送一个包就等待一个 ACK 号的方式是非常浪费时间的。为了减少时间的浪费，TCP 采用滑动窗口的方式发送数据，即不等待 ACK 号返回，直接发送后序的一系列包。
  - 采用滑动的窗口的方式需要解决一个问题即接收方的消息处理能力小于发送方发送消息的能力。所以在开始连接的时候，需要告知对方自己最多能接受多少数据即窗口的大小。
- ACK 与窗口的合并
  - ACK 号更新的时机：当接收方接收到数据时，如果确认内容没问题后，就可以向发送方返回 ACK 号。
  - 窗口大小更新的时机：当数据传递给应用程序之后才需要更新窗口大小。
  - 等待一段时间后可以合并的三种情况：
    - 发送 ACK 号的同时更新窗口大小。
    - 多个 ACK 合并为一个，只发送最后一个。
    - 窗口大小同上
- 接收 HTTP 响应消息
  - 应用程序调用 Scoket 库中的 read 程序组件。
  - 协议栈尝试从接收缓冲区中取出数据并传递给应用程序。如果接收缓冲区中没有数据，那么接收数据的操作无法继续，程序的工作将挂起。
  - 协议栈具体操作：
    - 协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。
    - 协议栈将数据块暂存到接收缓存区中，并将数据块按顺序连接起来还原出原始的数据。
    - 协议栈将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。
    - 协议栈寻找合适的时机向发送方发送窗口更新。



# 从服务器断开并删除套接字

- 数据发送完毕后断开连接
  - 假设以服务器一方发起断开过程为例来进行讲解。
  - 服务器一方的应用程序调用 Socket 库的 close 程序。
  - 服务器的协议栈生成包含断开信息的 TCP 头部，具体来说就是将控制位的 FIN 比特设为 1 。
  - 协议栈委托 IP 模块向客户端发送数据
  - 客户端收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。
  - 客户端会向服务器返回一个 ACK 号。
  - 应用程序调用 read 来读取数据。协议栈将剩余的已接收数据传递给应用程序，并告诉应用程序数据已经全部收到。
  - 客户端应用程序回调用 close 来结束数据收发操作。剩下操作于上述操作同理。
- 删除套接字
  - 和服务器的通信结束之后，套接字不会立刻被删除。
  - 断开流程如下：
    - 客户端发送 FIN
    - 服务器返回 ACK 号
    - 服务器发送 FIN
    - 客户端返回 ACK 号
  - 例子：假如客户端的 ACK 号丢失了，服务器可能回重发 FIN。如果客户端的套接字已经删除，并且有创建了一个新的套接字，并且端口号和旧的套接字的端口号相同。那么新的套接字就会执行断开操作。
- 数据收发操作小结
  - 创建套接字
    - 服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态。
    - 客户端则一般是在用户出发特定动作，需要访问服务器的时候创建套接字。
  - 建立连接
    - 客户端会生成一个 SYN 为 1 的 TCP 包并发送给服务器。TCP 包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。
    - 服务器返回一个 SYN 为 1 的 TCP 包。这个 TCP 的头部中也包含了序号和窗口大小。此外还包含表示确认已收到包的 ACK 号。
    - 客户端会向服务器返回一个包含表示确认的 ACK 号的 TCP 包。
  - 数据收发（以 Web 为例）
    - 客户端向服务器发送请求消息。TCP 会讲请求消息切分成一定大小的块，并在每一块前面加上 TCP 头部（包含序号），然后发送给服务器。
    - 当服务器收到数据时，会向客户端返回 ACK 号。
    - 服务器将数据传递给应用程序，接收缓冲区就会被释放。这时服务器将新的窗口大小告诉客户端。
    - 服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程相反。
  - 断开操作（以 Web 为例）
    - 服务器会先发起断开过程。服务器发送一个 FIN 为 1 的 TCP 包，然后客户端返回一个确认收发的 ACK 号。
    - 客户端的操作和上述相同。
    - 等待一段时候后，套接字被删除。



# IP 于以太网的包收发操作

- 包的基本知识

  - 包包含头部和数据两部分构成的。头部包含目的地址等控制信息。
  - 网络中有路由器和集线器两种不同的转发设备：
    - 路由器根据目标地址判断下一个路由器的位置（IP 协议根据目标地址判断下一个 IP 转发设备的位置）。
    - 集线器在子网中将网络包传输到下一个路由（子网中的以太网协议将包传输到下一个转发设备）。

- 包收发操作概览

  - TCP 模块委托 IP 模块发送包，需要指定通信对象的 IP 地址。
  - IP 模块会将包的内容当作一整块数据，并且添加 IP 头部和 MAC 头部这两种头部。
    - IP 头部包含 IP 协议的规定、根据 IP 地址将包发往目的地所需的控制信息。
    - MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息。
  - 封装好的包被教给网卡（网络硬件），例如以太网、无线局域网等。网卡将浙西数字信息转换为电信号或光信号，并通过网线发出去，这些型号会到集线器、路由器等转发设备，最后到达接收方。
  - 接收方网卡将电信号转换为数字信号并传递给 IP 模块。
  - IP 模块将 MAC 头部和 IP 头部后面的内容传递给 TCP 模块。

- 生成包含对方 IP 地址的 IP 头部

  - IP 头部格式

    | 字段名称        | 长度（比特） | 含义                                                         |
    | --------------- | ------------ | ------------------------------------------------------------ |
    | 版本号          | 4            | IP 协议版本号，目前使用的版本是 4                            |
    | 头部长度（IHL） | 4            | IP 头部的长度。可选字段可导致头部长度的变化，因此这里需要指定头部的长度 |
    | 服务类型（ToS） | 8            | 表示包传输优先级。最初的协议规格里对这个参数的规定非常模糊，最近 DiffServ 规格重新定义了这个字段的用法。 |
    | 总长度          | 16           | 表示 IP 消息的总长度                                         |
    | ID 号           | 16           | 用于识别包的编号，一般为包的序列号。如果一个包被 IP 分片，则所有分片都拥有相同的 ID |
    | 标志（Flag）    | 3            | 该字段有 3 个比特，其中 2 个有效，分别代表是否允许分片，以及当前包是否为分片包 |
    | 分片偏移量      | 13           | 表示当前包的内容为整个 IP 消息的第几个字节开始的内容         |
    | 生存时间（TTL） | 8            | 表示包的生存时间，这是为了避免网络出现回环时一个包永远在网络中打转。每经过一个路由器，这个值就会减1，减到0时这个包就会被丢弃 |
    |                 |              | 协议好表示协议的类型（一下均为十六进制）。<br />TCP：06<br />UDP：11<br />ICMP：01 |
    | 头部校验和      | 16           | 用于检查错误，现在已不使用                                   |
    | 发送方 IP 地址  | 32           | 网络包发送方的 IP 地址                                       |
    | 接收方 IP 地址  | 32           | 网络包接收方的 IP 地址                                       |
    | 可选字段        | 可变长度     | 除了上面的头部字段之外，还可以添加可选字段用于记录其他控制信息，但可选字段很少使用 |

  - IP 头部中的接收方 IP 地址来自于 TCP 模块，TCP 模块的 IP 地址来自于应用程序。

  - IP 头部中的发送方 IP 地址可以通过内置的 “IP 表” 获得（在 Linux 中，可以通过 route 命令查询）。

  - IP 头部中的协议号是根据委托的模块而设定的。TCP 模块则设置为 06（十六进制）；UDP 模块则为 17 （十六进制）。

- 生成以太网用的 MAC 头部

  - MAC 头部的字段

    | 字段名称        | 长度（比特） | 含义                                                         |
    | --------------- | ------------ | ------------------------------------------------------------ |
    | 接收方 MAC 地址 | 48           | 网络包接收方的 MAC 地址，在局域网中使用这一地址来传输网络包  |
    | 发送方 MAC 地址 | 48           | 网络包发送方的 MAC 地址，接收方通过它来判断是谁发送了这个包  |
    | 以太类型        | 16           | 使用的协议。下面是一些常见的类型，一般在 TCP/IP 通信中只使用 0800 和 0806 这两种。<br />0000-05DC：iEEE 802.3<br />0800：IP 协议<br />0806：ARP 协议<br />86DD：IPV6 |

  - 发送方 MAC 地址填网卡本身的 MAC 地址。

  - 接收方 MAC 地址通过 ARP 查询获得。

- 通过 ARP 查询目标路由器的 MAC 地址

  - ARP：Address Resolution Protocol，地址解析协议。
  - ARP 对整个以太网中的设备进行广播进行询问。如果对方和自己在同一个子网中，那么获得对方的 MAC 地址。
  - ARP 查询到的 MAC 地址会进行缓存。缓存的内容在几分钟后将被删除。

- 以太网的基本知识

  - 当具备一下三个性质的网络就是以太网：
    - 将包发送到 MAC 头部的接收方 MAC 地址代表的目的地。
    - 用发送方 MAC 地址识别发送方。
    - 用以太网类型识别包的内容。
  - 以太网的三种基本机构
    - 信号通过网线流过整个网络。
    - 信号通过中继式集线器扩散到整个网络。
    - 交换式集线器会根据接收方 MAC 地址将包转发到指定的目的地，因此信号只会到达指定的设备。

- 将 IP 包转换成电或光信号发送出去

  - 计算机启动操作系统的时候，网卡驱动会对硬件进行初始化操作，并将网卡 MAC 地址分配给 MAC 模块。
  - 网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的。

- 给网络包再加 3 个控制数据

  MAC 模块会将包从缓冲区取出，并在开头加上报头和起始帧分解符，在末尾加上用于检测错误的帧校验序列。

- 向集线器发送网络包

  - 网卡的 MAC 模块生成通用信号，然后由 PHY（MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。
  - PHY（MAU）负责将 MAC 模块传递过来的信号通过网线发送出去和监控接收线路中是否有信号进来。
  - 在发生碰撞的时候，将等待时间延长一倍，以此类推，当连续碰撞10次后，就报告通信错误。

- 接收返回包

  - PHY（MAU）模块会将信号转换成通用格式发送给 MAC 模块。
  - MAC 模块将信号转换为数字信息，并存放在缓冲区中。然后计算出 FCS 并与包尾的 FCS 进行比对，若不一致，则这个包被当作错误包而被丢弃。检查 MAC 头部中接收方 MAC 地址于网卡初始化时分配的 MAC 地址是否一致，如果不一致直接丢弃。并发出中断信号。
  - 网卡驱动通过 MAC 头部中的以太类型字段判断协议的类型，并把包交给相应的协议栈。

- 将服务器的响应包从 IP 包传递给 TCP

  - IP 模块会检查 IP 头部，确认格式是否正确并检查服务器返回的包的接收方 IP 地址是否与客户端网卡的地址一致。

  - 如果不一致，IP模块会通过 ICMP 消息将错误告知发送方。

  - 主要的 ICMP 消息

    | 消息                    | 类型 | 含义                                                         |
    | ----------------------- | ---- | ------------------------------------------------------------ |
    | Echo reply              | 0    | 响应 Echo 消息                                               |
    | Destination unreachable | 3    | 出于某些原因没有到达目的地而是被丢弃，则通过此消息通知发送方。可能的原因包括目标 IP 地址在路由器中不存在；目标端口号不存在对应的套接字；需要分片，但分片被禁用 |
    | Source quench           | 4    | 当发送的包数量超过路由器的转发能力，超过的部分会被丢弃，这时会通过这一消息通知发送方。但是，并不是说遇到这种情况一定会发送这一消息。当路由器的性能不足时，可能连这条消息都不发送，就直接把多余的包丢弃了。当发送方接收到这条消息时，必须降低发送速率 |
    | Redirect                | 5    | 当查询路由表后判断该包的入口和出口为同一个网络接口时，则表示这个包不需要该路由器转发，可以由发送方直接发送给下一个路由器。遇到这种情况时，路由器会发送这条消息，给出下一个路由器的 IP 地址，指示发送方直接发送过去 |
    | Echo                    | 8    | ping 命令发送的消息。收到这条消息的设备需要返回一个 Echo reply 消息，以便确认通信对象是否存在 |
    | Time exceeded           | 11   | 由于超过了 IP 头部中的 TTL 字段表示的存活时间而被路由器丢弃，此时路由器会向发送方发送这条消息 |
    | Parameter problem       | 12   | 由于 IP 头部字段存在错误而被丢弃，此时会向发送方发送这条消息 |

  - 如果一致，IP 模块等待 IP 头部中具有相同 ID 的包全部到达，并将这些包还原成原始的包，这个操作叫作分片重组。

  - TCP 模块根据 IP 头部中的接收方和发送方 IP 地址，以及 TCP 头部中的接收方和发送方端口号来查找对应的套接字。并改变套机字记录中的通信状态。

    - 如果包的内容是应用程序，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取。
    - 如果是建立或断开连接的控制包，则返回相应控制包，并告知应用程序建立和断开连接的操作状态。

# UDP 协议的收发操作

- 不需要重发的数据用 UDP 发送更高效

  - UDP 适合控制用的短数据以及音频和视频数据

  - UDP 头部中的控制信息

    | 字段名称     | 长度（比特） | 含义                   |
    | ------------ | ------------ | ---------------------- |
    | 发送方端口号 | 16           | 网络包发送方的端口号   |
    | 接收方端口号 | 16           | 网络包接收方的端口号   |
    | 数据长度     | 16           | UDP 头部后面数据的长度 |
    | 校验和       | 16           | 用于校验错误           |