# 基本概念

- 运输层为运行在不同主机上的应用程序之间提供 **逻辑通信**（logic communication）。
- 在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，分组称为运输层 **报文段**（segment）。
- 网络层提供 *主机* 之间的逻辑通信。运输层提供 *不同主机的进程* 之间的逻辑通信。
- IP 的服务模型是 **尽力而为交付服务**（best-offort delivery service），它是不可靠的。
- UDP 提供数据交付和差错检查两种服务。
- TCP 提供 数据交付、差错检查、可靠数据传输以及拥塞控制服务。
- 将运输层报文段中的数据交付到正确的套接字的工作称为 **多路分解**（demultiplexing）。
- 从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称之为 **多路复用**（multoplexing）。
- 一个 UDP 套接字是由一个二元组来全面标识的，该二元组包含一个目的 IP 地址和一个目的的端口号。
- 一个 TCP 套接字是由一个四元组来全面标识的，该四元组包含一个源 IP 地址、一个源端口号、一个目的目的 IP 地址，一个目的端口号。
- UDP 相对于 IP 层仅仅提供了复用/分解功能以及少量的差错检测功能。
- UDP 报文段结构
  源端口号（16 比特）、目的端口号（16 比特）、长度（16 比特）、校验和（16 比特）、应用数据（报文）这里的长度是指整个 UDP 报文段的长度，最小为 8 个字节。
- 生成校验和：首先将伪首部添加到 UDP 报文段上。伪首部包括源 IP 地址（32 比特）、目的 IP 地址（32 比特）、0（8 比特）、协议号（8 比特）、长度（16 比特）。将上述的所有位进行相加，如果溢出将被回卷。最后进行反码运算。
# 构造可靠数据传输协议

- 经完全可靠信道的可靠数据传输
  - 发送端：发送端应用层委托传输层发送报文。传输层将数据分成报文段，随后委托网络层将报文段发送给接收端。
  - 接收端：接收端传输层等待网络层的报文段。传输层将报文段重新整合成报文传递给应用层。
- 经具有比特差错的可靠数据传输
  - 发送端：发送端应用层委托传输层发送报文。传输层将报文分成报文段，随后委托网络层将报文段发送给接收端。随后发送端进入等待状态，等待接收端的确认，接收端的确认分为肯定确认和否定确认两种，肯定确认意味着报文段没有出现差错，否定确认意味着报文段出现差错。当发送端接收到肯定确认时，发送端可以进行下一个报文段的发送。当发送端接收到否请确认时，发送端重新发送当前报文段给接收端。但是这是出现了一个问题：当接收端返回的确认报文出现了差错，发送端该怎么办？一个解决办法是重新传输当前报文段。但是这又引出了另外一个问题：接收端并不知道发送端发送的报文是旧的报文还是新的报文。一个解决办法是报文段中添加序号字段。接收端可以根据报文段的序号字段来判断当前报文段是旧的报文段还是新的报文段。之前我们提到发送端会等待接收端的肯定确认和否定确认，实际上当有了序号字段以后就不需要否定确认了，发送端只需要根据确认的序号来判断是重新传输当前报文段，还是下一个报文段。具体的实现是，接收端确认时会发送它所需要的下一个报文段的序号，发送端仅需要发送该报文段就好。
  - 接收端：接收端传输层等待网络层的报文段。当接收到新的报文段时，首先判断该包是否出现差错，如果出现差错，则发送确认报文，该报文中包括已经接受的报文段中的下一个序列号。如果没有出现差错，则判断接收到的包的序列号是否为旧的包，如果是则直接和包出现差错的情况相同。如果不是，接收端等待下一个报文段的到达。
- 经具有比特差错的丢包信道的可靠数据传输
  - 发送端：和之前一样，发送端应用层委托运输层发送报文。传输层将报文分成报文段，随后委托网络层将报文段发送给接收端。因为现在网络层是可能将报文段直接丢失的，所以发送端的报文段和接收方的确认报文段都有可能丢失。怎么解决这个问题呢？我们可以在发送端这里设定一个倒计时器。在每次发送一个报文段后，便给倒计时器设定一个时间，当过了这个时间后，倒计时器便中断，发送端重新发送当前报文段。
  - 接收端：不需要做过多的改变。
- 流水线可靠数据传输协议
  - 刚刚说的那些协议都是停等协议，数据传输的效率非常低。解决这个问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。
  - 这样以后，发送端和接收端都必须具有一定大小的缓存空间来缓存接收到的报文段。这样以后会出现一个问题是，假如后面的报文段先到了，前面的报文段丢失了，该怎么办？有两种解决方案：一个是回退 N 步，一个是选择重传。
- 回退 N 步
  - 首先我们可以将一个缓存空间分为四个部分。第一个部分是已发送已确认、第二个部分是已发送未确认、第三个部分是未发送未确认、第四个部分是不能发送的部分。
  - 其中第二个部分和第三个部分的长度称为窗口大小，也就是回退 N 步中的 N。
  - 发送端
    - 当发送端应用层委托传输层发送报文时，运输层会检查窗口是否已满。如果已经满了，报文段将不会立刻发送，进入等待。
    - 当接收到 ACK 时，表明接收端已经接受到了 ACK 序号以及之前的所有分组。（累积确认）
    - 当超时时，发送端发送所有未确认的包。
  - 接收端
    - 如果接受端接收到了一个序号为 n 的报文段时，首先判断这个序号是否为上一次接收到的报文段的下一个序号。具体来说比如接收端上次确认接受了序号为 3 的报文段。那么现在接收端只能接受序号为 4 的报文段。其他报文段一律丢弃。
- 选择重传
  - 刚刚说的会退 N 步协议有一个缺陷是当窗口长度和带宽延时都非常大时，单个分组的差错可能会引发大量分组的重传。因此可以采用选择重传协议来让重新发送疑似出错的分组。
  - 发送端
    - 从上层收到数据。和回退 N 步一样，都是判断该序号是否在窗口。不做赘述。
    - 超时。因为是选择重传，每个报文段都不必须有自己的分组。当超时时，则重发该报文段。
    - 收到 ACK 时，如果该序号是在窗口内，则将该报文段标记为已接收。如果该序号恰好是窗口的起始位置，则可以移动窗口。
  - 接收端
    - 当接收的报文段的序号在窗口中时，发送 ACK 给发送方。如果该序号恰好是窗口的第一个序号，那么将缓存的连续的报文段交付给上层，接收端窗口向前移动。
    - 当接受到的序号在窗口之前时，发送 ACK。
    - 其他情况，忽略该分组。
# TCP

- TCP 协议是 **全双工服务**（full-duplex service）和 **点对点**（point-to-point）的协议
- TCP 三次握手的前两个报文段是不进行数据的有效传输的。第三个报文段可以进行数据的传输。
- TCP 报文段结构
  源端口号（16 比特）、目的端口号（16 比特）、序号（32 比特）、确认好（32 比特）、首部长度（4 比特）、标志位（6 比特）、接受窗口（16 比特）、校验和（16 比特）、紧急数据指针（16 比特）。
- **一个报文段的序号**（sequence number for a segment）是该报文段首字节的字节流编号。
- 估计往返时间
  - 计算估计时间 估计时间 = （1-a） * 估计时间 + a * 本次时间。
  - 计算偏差时间 偏差时间 =  (1 - b) * 偏差时间 + b * 偏差时间。
  - 等待时间 等待时间 = 估计时间 + 4 * 偏差时间
  - 等待时间初始化为 1 秒，当超时时，时间翻倍。当接收到报文时，那么等待时间的公式将重新启用。
- 快速重传
  - 因为计算往返时间的时候，等待时间是翻倍增长的，导致发送方等待时间过长。一个解决方案是当接受到 3 个冗余 ACK 时，TCP 就执行快速重传。
- TCP 既不是回退 N 步也不是选择重传，而是两者的结合。选择确认。
- 流量控制
  - 窗口大小等于缓存大小减去未读的字节数。发送端保持已经发送未确认的数据小于窗口大小。
- TCP 连接管理
  - 三次握手
    - 客户端向服务器发送一个报文段。该报文段不包含任何应用层信息。报文段中 SYN 字段设置为 1。报文段中的序号设置为一个随机值 a。
    - 服务器接收到该报文段。随后生成另一个报文段，该报文段中 SYN 字段设置为 1。报文段中的序号设置为 b，确认序号为 a + 1。
    - 客户端接收到服务器的报文段。返回一个报文段。该报文段包含了实际的应用层数据。该字段的序号为 a + 1，确认序号为 b + 1。
  - 四次挥手
    - 客户端向服务器发送一个 FIN 位被置为 1 的报文段。随后服务器返回 ACK 报文段确认。
    - 服务器同理。
  - 客户端状态变化
    - 客户端向服务器发送 SYN 报文段，从 CLOSED 进入 SYN_SEND 状态。
    - SYN_SEND 接收到 SYN & ACK 报文段，进入 ESTABLESHED 状态。
    - 客户端向服务器发送 FIN 报文段，进入 FIN_WAIT_1 状态。
    - 客户端收到 ACK 进入 FIN_WAIT_2 状态。
    - 客户端接收到 FIN 报文段，发送 ACK 报文段，进入 TIME_WAIT 状态。
    - 过 30 s，进入 CLOSED 状态。（假设 ACK 丢失，此时服务器关闭不了套接字）
  - 服务器状态变化
    - 服务器创建监听套接字，从 CLOSED 进入 LISTEN 状态。
    - 服务器接收到客户端的 SYN 报文段并发送 SYN & ACK 报文段，进入 SYN_RCVD 状态。
    - 服务器接收到客户端的 ACK 报文段，进入 ELSTABLISED 状态。
    - 服务器接收到客户端的 FIN 报文段发送 ACK 报文段，进入 CLOSE_WAIT 状态。
    - 服务器向客户端发送 FIN 报文段进入 LAST_ACK 状态。
    - 服务器接收到客户端的 ACK 报文段，进入 CLOSED 状态。
  - 为什么握手是三次，挥手是四次。
    - 握手的目的是明确的让双方都知道对方的秘密并且双方都知道对方知道自己的秘密。在 TCP 里面当 A 向 B 发送信息时（确认信息除外），B 也要向 A 发送确认信息。同理 B 向 A 发送消息时（确认信息除外），A 也要向 B 发送确认信息。我们发现在 B 向 A 发送确认消息的时候也可以把自己的秘密告诉对方，因此握手三次就足够了。
    - 我们假设握手只有两次会发生什么情况。A 告诉 B 关于 A 的秘密，同时 B 告诉 A 我收到了你的消息同时告诉 A 关于 B 的秘密。此时 B 并不知道对方是否已经接收到了消息。这就违反了 TCP 安全可靠的要求。
    - 如果遇上面试官问为什么不是四次时，明确的和对方讲你觉得第四次应该要干什么。
    - 挥手是四次的原因是 TCP 是双向传输的，既可以说话又可以听。第一次断开意味着我不想说话了，你也不需要听我说什么了。第二次是你不想说话了，我也不听了。
- TCP 拥塞控制
  - 慢启动
    -  cwnd 值设置为一个 MSS 的较小值。
    - 当传输成功时，cwnd 的值翻倍。
    - 当传输失败、丢包超时时，记 ssthresh 为 cwnd / 2，cwnd 设置为 1。重新开始以二倍的速率增长，当到达或超过 ssthresh 时，则进入拥塞避免状态
    - 当检测到 3 个冗余 ACK 时，快速重传，进入快速回复状态。
  - 拥塞避免
    - 每次传输成功时，swnd 的值加 1。
    - 当传输失败、丢包超时时，记 ssthresh 为 cwnd / 2，cwnd 设置为 1。重新开始以二倍的速率增长，当到达或超过 ssthresh 时，则进入拥塞避免状态
    - 当检测到 3 个冗余 ACK 时，将 cwnd 的值减半，ssthresh 设置为 cwnd 的值的一半。
  - 快速恢复
    - 没看懂
  - TCP 拥塞控制称为加性增，乘性减少。